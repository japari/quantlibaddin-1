"""
 Python source for QuantLib addin in LibreOffice/Calc.
 Copyright (C) 2016 Lars Callenbach

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""


import os
from code.configuration.addinconfiguration import AddinConfiguration
from code.logging.logger import Logger
from code.configuration.gensrcconfiguration import GensrcConfiguration
from code.configuration.parsemetadata import ParseMetaData
from code.codegeneration.addincode import AddinCode
from code.codegeneration.codegeneration import CodeGeneration
from code.parser.parameter import Parameter



HEADER="""/*
 Copyright (C) 2016 Lars Callenbach

 Autogenerated file from python source for QuantLib addin in LibreOffice/Calc.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/
"""



class CalcAddin(AddinConfiguration, CodeGeneration):
    """Class to generate code for Calc addin.
    
    It calls code generation routines from addinclasses.py (for constructors,
    member functions and enumerated objects) and stores the code in the files
    addin.*pp. Furthermore it generates the LibreOffice/
    Calc specific code in the files qlcalc.*pp and QuantLibAddinCalc.idl. Five 
    files are generated/updated by this routine. 
    
    Variables:
        metadata: Metadata (ParseMetaData instance)
        addin_name: Name of the Addin (Calc)
        constructors: Constructors (from parsemetadata.py)
        conversions: Conversions (from parsemetadata.py)
        memberfunctions: MemberFunctions (from parsemetadata.py)
        enumerations: Enumerations (from parsemetadata.py)
        template_arguments: Template arguments (from parsemetadata.py)
    """
    
    def __init__(self, path, addin_name, metadata):
        AddinConfiguration.__init__(self, path, addin_name)
        CodeGeneration.__init__(self)
        
        self.metadata = metadata
        self.addin_name = addin_name
        self.constructors = metadata.constructors
        self.memberfunctions = metadata.memberfunctions       
        self.conversions = metadata.conversions
        self.enumerations = metadata.enumerations
        self.template_arguments = metadata.template_arguments
        self.functions = metadata.functions
        
        self.idl_suffix = '_any'

        
    def generate_cpp(self):
        """Nothing to do...
        """
        True
        
        
    def generate_hpp(self):
        """Nothing to do...
        """
        True
        
        
    def generate(self):
        """Procedure to generate files with C++ code. 
        """
        Logger().info('start generation calc ...')
        
        self.idl_object_type = 'std::string'
        self.idl_to_cpp = 'IDL_'
        
        # first step: IDL file 
        idl_file_name = self.codePath + os.sep  + 'QuantLibAddinCalc.idl'
        with open(idl_file_name, "w") as text_file:
            text_file.write(self.generate_idl())

        # second step: addin code generation
        addin_code = AddinCode(self.conversions, self.constructors, \
                    self.enumerations, self.memberfunctions, \
                    self.template_arguments, self.functions, \
                    self.idl_object_type, self.idl_to_cpp, self.addin_name, \
                    self.idl_suffix)
        addin_file_name_cpp = self.codePath + os.sep + 'addin.cpp'
        with open(addin_file_name_cpp, "w") as text_file:
            text_file.write(HEADER)
            code = addin_code.generate_cpp()
            text_file.write(self.get_text(code))
        
        addin_file_name_hpp = self.codePath + os.sep + 'addin.hpp'
        with open(addin_file_name_hpp, "w") as text_file:
            text_file.write(HEADER)
            code = addin_code.generate_hpp()
            text_file.write(self.get_text(code))
        
        #third step: addin specific code 
        code_gen = addin_code.addin_classes_code

        (cpp1, hpp1) = self.generate_constructors(code_gen)
        (cpp2, hpp2) = self.generate_memberfunctions(code_gen)
        (cpp3, hpp3) = self.generate_functions(code_gen)

        help_code = self.generate_help()
        
        filename = self.codePath + os.sep + 'qlcalc.cpp'    
        with open(filename, "w") as text_file:
            code = cpp1 + cpp2 + cpp3
            code_txt = self.get_text(code)
            help_txt = self.get_text(help_code)
            text = self.text_addin_cpp % (code_txt, help_txt)
            text_file.write(text)

        filename = self.codePath + os.sep + 'qlcalc.hpp'    
        with open(filename, "w") as text_file:
            code = hpp1 + hpp2 + hpp3
            shifted_code = self.shift_text(1, code)
            code_txt = self.get_text(shifted_code)
            text = self.text_addin_hpp % (code_txt)
            text_file.write(text)

        Logger().info('end generatation calc ...')
        
        
    def generate_constructors(self, addin_classes):
        """Function to generate code for constructor invocation.
        
        This function generates the code for constructors that should be stored
        in the ObjectHandler. The function header will be generated by the 
        function generate_idl_param_declaration(). 
        
        Constructors are "passed through" to the addin classes. The main part
        the storage code for the ObjectHandler. 
        
        Argument:
            addin_classes: Instance of AddinClasses for conversions.
        
        Return:
            List of code (Tuple(idention, C++ code as text))
        """
        
        lines_cpp = []
        lines_hpp = []
        for key1 in self.constructors.keys():
            constr = self.constructors[key1][0]
            constr_class = constr.get_classname()
            para_list = constr.get_parameters()
            
            para_object = Parameter('std::string ObjectId')
            
            excl_list = [('IDL_long', 0), ('IDL_double', 0)]
            (para_list_idl, args) = self.generate_idl_param_declaration(
                        addin_classes, para_list, excl_list, True)
            addin_name = key1.addin_name
            var_object = 'ObjectId' + addin_classes.suffix
            addin_class = addin_classes.get_addintype(constr_class)
            
            line = 'SEQSEQ(IDL_any) SAL_CALL %s%s;' % (addin_name, \
                    para_list_idl)
            lines_hpp.append((0, line))
            
            line = 'SEQSEQ(IDL_any) SAL_CALL CalcAddins_impl::%s%s {' % \
                    (addin_name, para_list_idl)
            lines_cpp.append((0, line))
            line = 'try { '
            lines_cpp.append((1, line))
            code = addin_classes._para_conv_type('std::string', \
                                                        para_object)
            lines_cpp += self.shift_text(2, code)
            line = 'ObjectHandler::Repository::instance().storeObject(%s,' % \
                     var_object 
            lines_cpp.append((2, line))
            line = 'boost::shared_ptr<ObjectHandler::Object>(new %s%s));' % \
                    (addin_class, args)
            lines_cpp.append((3, line))
            
            line = 'std::string returnValue = ObjectId_cpp;'
            lines_cpp.append((2, line))
            
            parameter = Parameter('std::string String')       
            code = self.convert_result_to_idl(parameter, addin_classes)
            lines_cpp += self.shift_text(2, code)
            code = self.generate_catchblock(addin_name)
            lines_cpp += self.shift_text(1, code)
            lines_cpp.append((0, '};'))
            
        return (lines_cpp, lines_hpp)
        
    
    def generate_memberfunctions(self, addin_classes):
        """Function to generate code for member function invocation.
        
        This function generates the code for member functions. The function 
        header will be generated by generate_idl_param_declaration(). 
        
        Member function calls are "passed through" to the addin classes. The 
        conversion of the object to the appropriate type will be done in the 
        addin classes code. 
        
        Argument:
            addin_classes: Instance of AddinClasses for conversions.

        Return:
            List of code (Tuple(idention, C++ code as text))
        """
        lines_cpp = []
        lines_hpp = []
        for key1 in self.memberfunctions.keys():
            mem_func_class = self.memberfunctions[key1][0]
            mem_func_class_name = mem_func_class.get_classname()
            addin_class = addin_classes.get_addintype(mem_func_class_name)
            
            mem_func = self.memberfunctions[key1][1]
            func_name = mem_func.get_functionname()
            if func_name=='operator()':
                func_name = 'addinOperator'
            para_list = mem_func.get_parameters()
            
            excl_list = [('IDL_long', 0), ('IDL_double', 0)]
            (para_list_idl, args) = self.generate_idl_param_declaration(
                        addin_classes, para_list, excl_list, False)
            (addin_type, inc_file, prototype, function_call, addin_name) = key1

            line = 'SEQSEQ(IDL_any) SAL_CALL %s%s;' % (addin_name, \
                    para_list_idl)
            lines_hpp.append((0, line))
            
            line ='SEQSEQ(IDL_any) SAL_CALL CalcAddins_impl::%s%s {' % \
                    (addin_name, para_list_idl)
            lines_cpp.append((0, line))
            line = 'try {'
            lines_cpp.append((1, line))
            
            return_type = mem_func.get_returntype()
            if return_type!='void': 
                line = '%s returnValue;' % return_type
                lines_cpp.append((2, line))
                
                line = 'returnValue = %s::%s%s;' % (addin_class, func_name, args)            
                lines_cpp.append((2, line))
                code = self.convert_result_to_idl( \
                                        mem_func.get_returntype_parameter(), \
                                        addin_classes)
                lines_cpp += self.shift_text(2, code)
            else:
                line = '%s::%s%s;' % (addin_class, func_name, args)            
                lines_cpp.append((2, line))
                
                code = self.generate_voidreturn()
                lines_cpp += self.shift_text(2, code)
                
            code = self.generate_catchblock(addin_name)
            lines_cpp += self.shift_text(1, code)
            lines_cpp.append((0, '};'))
            
        return (lines_cpp, lines_hpp)
        
    
    def generate_functions(self, addin_classes):
        """Function to generate code for function invocation.
        
        This function generates the code for functions. The function 
        header will be generated by generate_idl_param_declaration(). 
        
        Function calls are "passed through" to the addin classes. The 
        conversion of the object to the appropriate type will be done in the 
        addin classes code. 
        
        Argument:
            addin_classes: Instance of AddinClasses for conversions.

        Return:
            List of code (Tuple(idention, C++ code as text))
        """
        lines_cpp = []
        lines_hpp = []
        for key1 in self.functions.keys():            
            func = self.functions[key1][1]
            func_name = func.get_functionname()
            func_namecall = addin_classes.get_addintype(func_name)
            para_list = (func.get_parameters())[1:]
            
            excl_list = [('IDL_long', 0), ('IDL_double', 0)]
            (para_list_idl, args) = self.generate_idl_param_declaration(
                        addin_classes, para_list, excl_list, False)
            (addin_type, inc_file, prototype, function_call, addin_name) = key1

            line = 'SEQSEQ(IDL_any) SAL_CALL %s%s;' % (addin_name, \
                    para_list_idl)
            lines_hpp.append((0, line))
            
            line ='SEQSEQ(IDL_any) SAL_CALL CalcAddins_impl::%s%s {' % \
                    (addin_name, para_list_idl)
            lines_cpp.append((0, line))
            line = 'try {'
            lines_cpp.append((1, line))
            
            return_type = func.get_returntype()
            if return_type!='void': 
                line = '%s returnValue;' % return_type
                lines_cpp.append((2, line))
                
                line = 'returnValue = %s%s;' % (func_namecall, args)            
                lines_cpp.append((2, line))
                code = self.convert_result_to_idl( \
                                        func.get_returntype_parameter(), \
                                        addin_classes)
                lines_cpp += self.shift_text(2, code)
            else:
                line = '%s%s;' % (func_namecall, args)            
                lines_cpp.append((2, line))
                
                code = self.generate_voidreturn()
                lines_cpp += self.shift_text(2, code)
                
            code = self.generate_catchblock(addin_name)
            lines_cpp += self.shift_text(1, code)
            lines_cpp.append((0, '};'))
            
        return (lines_cpp, lines_hpp)
        
        
    def convert_result_to_idl(self, parameter, addin_classes):
        """Function to generate code for conversion from C++ to IDL.
        
        This function generates the code for the return values. 
        
        Argument:
            parameter: Return parameter (of type Parameter) to be analysed
            addin_classes: Instance of AddinClasses for conversions.
        
        Return:
            List of code (Tuple(idention, C++ code as text))
        """
        lines = []
        class_name = parameter.get_classname()
        typ_idl = addin_classes.prefix
        typ_idl += addin_classes.find_conversion(class_name).idl                

        dimension = parameter.get_dimension()            

        convert_to_idl = addin_classes.find_conversion(class_name).toidl    
        if convert_to_idl=='Default':
            convert_to_idl = 'convertToIdl'
            
        line = '// return value'
        lines.append((0, line))
        if dimension==0:
            line = typ_idl + ' returnValueCalc;'
        else:
            line = 'SEQSEQ(' + typ_idl + ') returnValueCalc;'
        lines.append((0, line))
            
        line = 'interfaceFromCpp(returnValue, returnValueCalc, %s);' % \
                convert_to_idl
        lines.append((0, line))
        line = 'SEQSEQ(IDL_any) returnValueAny;'
        lines.append((0, line))
        line = 'idlConversionToAny(returnValueCalc, returnValueAny);'
        lines.append((0, line))
        line = 'return returnValueAny;'
        lines.append((0, line))

        return lines

        
    def generate_idl(self):
        """Function to generate text for the IDL file definition. 
        
        Return:
            Text
        """
        function_text = ''
        local_text = self.text_idl_func

        # constructors
        for key in list(self.constructors.keys()):            
            function_name = key[-1]
            data = self.constructors[key][0]
            
            parameter_liste = ''
            for parameter in data.get_parameters():
                class_name = parameter.get_classname()
                idl_typ = self.metadata.find_idltype(self.idl_object_type, \
                                                     class_name)
                typ = idl_typ
                # overwrite for general type any
                typ = 'any'
                idl_typ = typ
                dimension = parameter.get_dimension()
                conv = self.metadata.find_conversion(None, class_name)
                if conv is not None and conv.flag is not None and \
                  (conv.flag==1 or conv.flag==2):
                    dimension = conv.flag
                if dimension>0:
                    typ = 'sequence<sequence<'+idl_typ+' > >'
                parameter_liste = parameter_liste + '\n\t\t\t[in] ' + typ 
                parameter_liste = parameter_liste + ' ' + \
                                    parameter.get_variablename() + ','
            parameter_liste = parameter_liste[:-1]
            
            function_text = function_text + local_text % \
                            (function_name, parameter_liste) + '\n'
            
        # member functions
        for key in list(self.memberfunctions.keys()):
            function_name = key[-1]
            
            data = self.memberfunctions[key][1]
            
            parameter_liste = ''
            for parameter in data.get_parameters():
                class_name = parameter.get_classname()
                idl_typ = self.metadata.find_idltype(self.idl_object_type, \
                                                     class_name)
                typ = idl_typ
                # overwrite for general type any
                typ = 'any'
                idl_typ = typ
                conv = self.metadata.find_conversion(None, class_name)
                if conv is not None and conv.flag is not None and \
                  (conv.flag==1 or conv.flag==2):
                    dimension = conv.flag
                if dimension>0:
                    typ = 'sequence<sequence<'+idl_typ+' > >'
                parameter_liste = parameter_liste + '\n\t\t\t[in] ' + idl_typ 
                parameter_liste = parameter_liste + ' ' + \
                        parameter.get_variablename() + ','
            parameter_liste = parameter_liste[:-1]
            
            function_text = function_text + local_text % \
                        (function_name, parameter_liste) + '\n'
        
        # functions
        for key in list(self.functions.keys()):
            function_name = key[-1]
            
            data = self.functions[key][1]
            
            parameter_liste = ''
            first_para = True
            for parameter in data.get_parameters():
                if first_para:
                    first_para = False
                    continue
                class_name = parameter.get_classname()
                idl_typ = self.metadata.find_idltype(self.idl_object_type, \
                                                     class_name)
                typ = idl_typ
                # overwrite for general type any
                typ = 'any'
                idl_typ = typ
                conv = self.metadata.find_conversion(None, class_name)
                if conv is not None and conv.flag is not None and \
                  (conv.flag==1 or conv.flag==2):
                    dimension = conv.flag
                if dimension>0:
                    typ = 'sequence<sequence<'+idl_typ+' > >'
                parameter_liste = parameter_liste + '\n\t\t\t[in] ' + idl_typ 
                parameter_liste = parameter_liste + ' ' + \
                        parameter.get_variablename() + ','
            parameter_liste = parameter_liste[:-1]
            
            function_text = function_text + local_text % \
                        (function_name, parameter_liste) + '\n'

        return self.text_idl_header % { 'buffer' : function_text }


    def generate_help(self):
        """Function to generate code for the help text.
        
        Help text will display the variable names and variable types. 
        
        Return:
            List of code (Tuple(idention, C++ code as text))
        """
        
        lines = []
        
        for key in self.constructors.keys():
            addin_name = key.addin_name
            addin_txt = 'STRFROMANSI("' + addin_name + '")'

            line = 'funcMap[%s] = %s;' % (addin_txt, addin_txt)
            lines.append((0, line))
            line = 'funcDesc[%s] = STRFROMANSI("Consructor.");' % addin_txt
            lines.append((0, line))
            
            for para in self.constructors[key][0].get_parameters():
                line = 'argName[%s].push_back(STRFROMANSI("%s"));' % \
                        (addin_txt, para.get_variablename())
                lines.append((0, line))
                desc = para.get_classname()
                default_val = para.get_defaultvalue()
                if default_val is not None:
                    desc = '%s (default value %s)' % (desc, default_val)
                line = 'argDesc[%s].push_back(STRFROMANSI("%s"));' % \
                        (addin_txt, desc)
                lines.append((0, line))
            
        for key in self.memberfunctions.keys():
            addin_name = key.addin_name
            addin_txt = 'STRFROMANSI("' + addin_name + '")'

            line = 'funcMap[%s] = %s;' % (addin_txt, addin_txt)
            lines.append((0, line))
            line = 'funcDesc[%s] = STRFROMANSI("return type: %s.");' % \
                    (addin_txt, self.memberfunctions[key][1].get_returntype())
            lines.append((0, line))
            
            for para in self.memberfunctions[key][1].get_parameters():
                line = 'argName[%s].push_back(STRFROMANSI("%s"));' % \
                        (addin_txt, para.get_variablename())
                lines.append((0, line))
                desc = para.get_classname()
                default_val = para.get_defaultvalue()
                if default_val is not None:
                    desc = '%s (default value %s)' % (desc, default_val)
                line = 'argDesc[%s].push_back(STRFROMANSI("%s"));' % \
                        (addin_txt, desc)
                lines.append((0, line))
            
        for key in self.functions.keys():
            addin_name = key.addin_name
            addin_txt = 'STRFROMANSI("' + addin_name + '")'

            line = 'funcMap[%s] = %s;' % (addin_txt, addin_txt)
            lines.append((0, line))
            line = 'funcDesc[%s] = STRFROMANSI("return type: %s.");' % \
                    (addin_txt, self.functions[key][1].get_returntype())
            lines.append((0, line))
            
            for para in (self.functions[key][1].get_parameters())[1:]:
                line = 'argName[%s].push_back(STRFROMANSI("%s"));' % \
                        (addin_txt, para.get_variablename())
                lines.append((0, line))
                desc = para.get_classname()
                default_val = para.get_defaultvalue()
                if default_val is not None:
                    desc = '%s (default value %s)' % (desc, default_val)
                line = 'argDesc[%s].push_back(STRFROMANSI("%s"));' % \
                        (addin_txt, desc)
                lines.append((0, line))

        return lines
        
        
    def generate_catchblock(self, addin_class):
        """Function to generate code for the catch block.
        
        The catch block should catch Exceptions and handle them gracefully.
        The exception message will be displayed in Calc.
        
        Arguments:
            addin_class: Name of the Addin class in which the Exception is 
                thrown
        
        Return:
            List of code (Tuple(idention, C++ code as text))
        """
        lines = []
        line = '} catch (const std::exception &e) {'
        lines.append((0, line))
        line = 'do {' 
        lines.append((1, line))
        line = 'std::ostringstream errorMsg; '
        lines.append((2, line))
        line = 'errorMsg << "ERROR: %s:  " << e.what();' % addin_class
        lines.append((2, line))
                
        line = 'SEQSEQ(IDL_any) retAnyArray;'
        lines.append((2, line))
        line = 'retAnyArray.realloc(1);'
        lines.append((2, line))
        line = 'SEQ(IDL_any) retAnyVector(1);'
        lines.append((2, line))
        line = 'IDL_string s = STRFROMASCII( errorMsg.str().c_str() );'
        lines.append((2, line))
        line = 'retAnyVector[0] = CSS::uno::makeAny( s );'
        lines.append((2, line))
        line = 'retAnyArray[0] = retAnyVector;'
        lines.append((2, line))
        line = 'return retAnyArray;'
        lines.append((2, line))
        line = '} while (false);'
        lines.append((1, line))
        line = '}'
        lines.append((0, line))
        
        return lines
        
        
    def generate_voidreturn(self):
        """Function to generate code member functions with return type void.
        
        Return:
            List of code (Tuple(idention, C++ code as text))
        """
        lines = []
        line = 'std::string returnString=std::string("OK");' 
        lines.append((0, line))                
        line = 'SEQSEQ(IDL_any) retAnyArray;'
        lines.append((0, line))
        line = 'retAnyArray.realloc(1);'
        lines.append((0, line))
        line = 'SEQ(IDL_any) retAnyVector(1);'
        lines.append((0, line))
        line = 'IDL_string s = STRFROMASCII( returnString.c_str() );'
        lines.append((0, line))
        line = 'retAnyVector[0] = CSS::uno::makeAny( s );'
        lines.append((0, line))
        line = 'retAnyArray[0] = retAnyVector;'
        lines.append((0, line))
        line = 'return retAnyArray;'
        lines.append((0, line))
        return lines
        
            
    def generate_idl_param_declaration(self, addin_classes, parameter_list, 
                                       excl_list=[], excl_first=False):
        """Function to generate code for parameter declaration.

        Arguments:
            addin_classes: Instance of AddinClasses
            parameter_list: List of parameters (of type Parameter)
            excl_list: List of types for which the C++ classifier 'const' 
                should not be set
            excl_first: Boolean flag to exclude first argument (different for 
                constructors and member functions)
        
        Return:
            Tuple (declaration as text, argument list (variable names) as text)
        """
        text = '('
        argument_list = ''
        found_parameter = False
        for parameter in parameter_list:
            class_name = parameter.get_classname()
            conv = addin_classes.find_conversion(class_name)
            typ = addin_classes.prefix + conv.idl
            typ = addin_classes.prefix + 'any'

            variable_name = parameter.get_variablename()
            dimension = parameter.get_dimension()
            if conv.flag is not None and (conv.flag==1 or conv.flag==2):
                dimension = conv.flag
            dimension_text = ''
            if dimension>0:
                dimension_text = 'SEQSEQ('
            if (typ, dimension) not in excl_list:
                text = text + 'const '
            text = text + dimension_text + typ 
            if dimension>0:
                text = text + ')'
            text = text + ' ' 
            if (typ, dimension) not in excl_list:
                text = text + '&'
            text = text + variable_name + self.idl_suffix + ', '
            found_parameter = True

            if excl_first:
                excl_first = False
                continue             
            argument_list = argument_list + ', ' + variable_name + self.idl_suffix
            
        if found_parameter:
            text = text[:-2]
        if len(argument_list)>1:
            argument_list = argument_list[2:]

        argument_list = '(' + argument_list + ')'
        text = text + ')'
        
        return (text, argument_list)
            
        
        

if __name__ == "__main__":
    gensrc_configuration = GensrcConfiguration('../..')
    metadata = ParseMetaData('../../metadata', 'Calc')
    Logger().info(metadata.conversions)
    addin = CalcAddin('../../config', 'calc', metadata)
    addin.generate()
